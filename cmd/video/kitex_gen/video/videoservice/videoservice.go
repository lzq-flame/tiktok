// Code generated by Kitex v0.3.1. DO NOT EDIT.

package videoservice

import (
	"context"
	"example/cmd/video/kitex_gen/video"
	"fmt"
	"github.com/cloudwego/kitex/client"
	kitex "github.com/cloudwego/kitex/pkg/serviceinfo"
	"github.com/cloudwego/kitex/pkg/streaming"
	"google.golang.org/protobuf/proto"
)

func serviceInfo() *kitex.ServiceInfo {
	return videoServiceServiceInfo
}

var videoServiceServiceInfo = NewServiceInfo()

func NewServiceInfo() *kitex.ServiceInfo {
	serviceName := "VideoService"
	handlerType := (*video.VideoService)(nil)
	methods := map[string]kitex.MethodInfo{
		"CreateVideo":    kitex.NewMethodInfo(createVideoHandler, newCreateVideoArgs, newCreateVideoResult, false),
		"GetVideoFeed":   kitex.NewMethodInfo(getVideoFeedHandler, newGetVideoFeedArgs, newGetVideoFeedResult, false),
		"GetPublishList": kitex.NewMethodInfo(getPublishListHandler, newGetPublishListArgs, newGetPublishListResult, false),
		"AddFavorite":    kitex.NewMethodInfo(addFavoriteHandler, newAddFavoriteArgs, newAddFavoriteResult, false),
		"RmFavorite":     kitex.NewMethodInfo(rmFavoriteHandler, newRmFavoriteArgs, newRmFavoriteResult, false),
		"FavoriteVideo":  kitex.NewMethodInfo(favoriteVideoHandler, newFavoriteVideoArgs, newFavoriteVideoResult, false),
	}
	extra := map[string]interface{}{
		"PackageName": "user",
	}
	svcInfo := &kitex.ServiceInfo{
		ServiceName:     serviceName,
		HandlerType:     handlerType,
		Methods:         methods,
		PayloadCodec:    kitex.Protobuf,
		KiteXGenVersion: "v0.3.1",
		Extra:           extra,
	}
	return svcInfo
}

func createVideoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.CreateVideoRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).CreateVideo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *CreateVideoArgs:
		success, err := handler.(video.VideoService).CreateVideo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*CreateVideoResult)
		realResult.Success = success
	}
	return nil
}
func newCreateVideoArgs() interface{} {
	return &CreateVideoArgs{}
}

func newCreateVideoResult() interface{} {
	return &CreateVideoResult{}
}

type CreateVideoArgs struct {
	Req *video.CreateVideoRequest
}

func (p *CreateVideoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in CreateVideoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *CreateVideoArgs) Unmarshal(in []byte) error {
	msg := new(video.CreateVideoRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var CreateVideoArgs_Req_DEFAULT *video.CreateVideoRequest

func (p *CreateVideoArgs) GetReq() *video.CreateVideoRequest {
	if !p.IsSetReq() {
		return CreateVideoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *CreateVideoArgs) IsSetReq() bool {
	return p.Req != nil
}

type CreateVideoResult struct {
	Success *video.CreateVideoResp
}

var CreateVideoResult_Success_DEFAULT *video.CreateVideoResp

func (p *CreateVideoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in CreateVideoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *CreateVideoResult) Unmarshal(in []byte) error {
	msg := new(video.CreateVideoResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *CreateVideoResult) GetSuccess() *video.CreateVideoResp {
	if !p.IsSetSuccess() {
		return CreateVideoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *CreateVideoResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.CreateVideoResp)
}

func (p *CreateVideoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getVideoFeedHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.GetVideoFeedRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).GetVideoFeed(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetVideoFeedArgs:
		success, err := handler.(video.VideoService).GetVideoFeed(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetVideoFeedResult)
		realResult.Success = success
	}
	return nil
}
func newGetVideoFeedArgs() interface{} {
	return &GetVideoFeedArgs{}
}

func newGetVideoFeedResult() interface{} {
	return &GetVideoFeedResult{}
}

type GetVideoFeedArgs struct {
	Req *video.GetVideoFeedRequest
}

func (p *GetVideoFeedArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetVideoFeedArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetVideoFeedArgs) Unmarshal(in []byte) error {
	msg := new(video.GetVideoFeedRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetVideoFeedArgs_Req_DEFAULT *video.GetVideoFeedRequest

func (p *GetVideoFeedArgs) GetReq() *video.GetVideoFeedRequest {
	if !p.IsSetReq() {
		return GetVideoFeedArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetVideoFeedArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetVideoFeedResult struct {
	Success *video.GetVideoFeedResp
}

var GetVideoFeedResult_Success_DEFAULT *video.GetVideoFeedResp

func (p *GetVideoFeedResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetVideoFeedResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetVideoFeedResult) Unmarshal(in []byte) error {
	msg := new(video.GetVideoFeedResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetVideoFeedResult) GetSuccess() *video.GetVideoFeedResp {
	if !p.IsSetSuccess() {
		return GetVideoFeedResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetVideoFeedResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.GetVideoFeedResp)
}

func (p *GetVideoFeedResult) IsSetSuccess() bool {
	return p.Success != nil
}

func getPublishListHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.GetPublishListRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).GetPublishList(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *GetPublishListArgs:
		success, err := handler.(video.VideoService).GetPublishList(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*GetPublishListResult)
		realResult.Success = success
	}
	return nil
}
func newGetPublishListArgs() interface{} {
	return &GetPublishListArgs{}
}

func newGetPublishListResult() interface{} {
	return &GetPublishListResult{}
}

type GetPublishListArgs struct {
	Req *video.GetPublishListRequest
}

func (p *GetPublishListArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in GetPublishListArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *GetPublishListArgs) Unmarshal(in []byte) error {
	msg := new(video.GetPublishListRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var GetPublishListArgs_Req_DEFAULT *video.GetPublishListRequest

func (p *GetPublishListArgs) GetReq() *video.GetPublishListRequest {
	if !p.IsSetReq() {
		return GetPublishListArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *GetPublishListArgs) IsSetReq() bool {
	return p.Req != nil
}

type GetPublishListResult struct {
	Success *video.GetPublishListResp
}

var GetPublishListResult_Success_DEFAULT *video.GetPublishListResp

func (p *GetPublishListResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in GetPublishListResult")
	}
	return proto.Marshal(p.Success)
}

func (p *GetPublishListResult) Unmarshal(in []byte) error {
	msg := new(video.GetPublishListResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *GetPublishListResult) GetSuccess() *video.GetPublishListResp {
	if !p.IsSetSuccess() {
		return GetPublishListResult_Success_DEFAULT
	}
	return p.Success
}

func (p *GetPublishListResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.GetPublishListResp)
}

func (p *GetPublishListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func addFavoriteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.AddFavoriteRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).AddFavorite(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *AddFavoriteArgs:
		success, err := handler.(video.VideoService).AddFavorite(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*AddFavoriteResult)
		realResult.Success = success
	}
	return nil
}
func newAddFavoriteArgs() interface{} {
	return &AddFavoriteArgs{}
}

func newAddFavoriteResult() interface{} {
	return &AddFavoriteResult{}
}

type AddFavoriteArgs struct {
	Req *video.AddFavoriteRequest
}

func (p *AddFavoriteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in AddFavoriteArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *AddFavoriteArgs) Unmarshal(in []byte) error {
	msg := new(video.AddFavoriteRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var AddFavoriteArgs_Req_DEFAULT *video.AddFavoriteRequest

func (p *AddFavoriteArgs) GetReq() *video.AddFavoriteRequest {
	if !p.IsSetReq() {
		return AddFavoriteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *AddFavoriteArgs) IsSetReq() bool {
	return p.Req != nil
}

type AddFavoriteResult struct {
	Success *video.AddFavoriteResp
}

var AddFavoriteResult_Success_DEFAULT *video.AddFavoriteResp

func (p *AddFavoriteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in AddFavoriteResult")
	}
	return proto.Marshal(p.Success)
}

func (p *AddFavoriteResult) Unmarshal(in []byte) error {
	msg := new(video.AddFavoriteResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *AddFavoriteResult) GetSuccess() *video.AddFavoriteResp {
	if !p.IsSetSuccess() {
		return AddFavoriteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *AddFavoriteResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.AddFavoriteResp)
}

func (p *AddFavoriteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func rmFavoriteHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.RmFavoriteRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).RmFavorite(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *RmFavoriteArgs:
		success, err := handler.(video.VideoService).RmFavorite(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*RmFavoriteResult)
		realResult.Success = success
	}
	return nil
}
func newRmFavoriteArgs() interface{} {
	return &RmFavoriteArgs{}
}

func newRmFavoriteResult() interface{} {
	return &RmFavoriteResult{}
}

type RmFavoriteArgs struct {
	Req *video.RmFavoriteRequest
}

func (p *RmFavoriteArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in RmFavoriteArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *RmFavoriteArgs) Unmarshal(in []byte) error {
	msg := new(video.RmFavoriteRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var RmFavoriteArgs_Req_DEFAULT *video.RmFavoriteRequest

func (p *RmFavoriteArgs) GetReq() *video.RmFavoriteRequest {
	if !p.IsSetReq() {
		return RmFavoriteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *RmFavoriteArgs) IsSetReq() bool {
	return p.Req != nil
}

type RmFavoriteResult struct {
	Success *video.RmFavoriteResp
}

var RmFavoriteResult_Success_DEFAULT *video.RmFavoriteResp

func (p *RmFavoriteResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in RmFavoriteResult")
	}
	return proto.Marshal(p.Success)
}

func (p *RmFavoriteResult) Unmarshal(in []byte) error {
	msg := new(video.RmFavoriteResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *RmFavoriteResult) GetSuccess() *video.RmFavoriteResp {
	if !p.IsSetSuccess() {
		return RmFavoriteResult_Success_DEFAULT
	}
	return p.Success
}

func (p *RmFavoriteResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.RmFavoriteResp)
}

func (p *RmFavoriteResult) IsSetSuccess() bool {
	return p.Success != nil
}

func favoriteVideoHandler(ctx context.Context, handler interface{}, arg, result interface{}) error {
	switch s := arg.(type) {
	case *streaming.Args:
		st := s.Stream
		req := new(video.FavoriteVideoRequest)
		if err := st.RecvMsg(req); err != nil {
			return err
		}
		resp, err := handler.(video.VideoService).FavoriteVideo(ctx, req)
		if err != nil {
			return err
		}
		if err := st.SendMsg(resp); err != nil {
			return err
		}
	case *FavoriteVideoArgs:
		success, err := handler.(video.VideoService).FavoriteVideo(ctx, s.Req)
		if err != nil {
			return err
		}
		realResult := result.(*FavoriteVideoResult)
		realResult.Success = success
	}
	return nil
}
func newFavoriteVideoArgs() interface{} {
	return &FavoriteVideoArgs{}
}

func newFavoriteVideoResult() interface{} {
	return &FavoriteVideoResult{}
}

type FavoriteVideoArgs struct {
	Req *video.FavoriteVideoRequest
}

func (p *FavoriteVideoArgs) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetReq() {
		return out, fmt.Errorf("No req in FavoriteVideoArgs")
	}
	return proto.Marshal(p.Req)
}

func (p *FavoriteVideoArgs) Unmarshal(in []byte) error {
	msg := new(video.FavoriteVideoRequest)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Req = msg
	return nil
}

var FavoriteVideoArgs_Req_DEFAULT *video.FavoriteVideoRequest

func (p *FavoriteVideoArgs) GetReq() *video.FavoriteVideoRequest {
	if !p.IsSetReq() {
		return FavoriteVideoArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *FavoriteVideoArgs) IsSetReq() bool {
	return p.Req != nil
}

type FavoriteVideoResult struct {
	Success *video.FavoriteVideoResp
}

var FavoriteVideoResult_Success_DEFAULT *video.FavoriteVideoResp

func (p *FavoriteVideoResult) Marshal(out []byte) ([]byte, error) {
	if !p.IsSetSuccess() {
		return out, fmt.Errorf("No req in FavoriteVideoResult")
	}
	return proto.Marshal(p.Success)
}

func (p *FavoriteVideoResult) Unmarshal(in []byte) error {
	msg := new(video.FavoriteVideoResp)
	if err := proto.Unmarshal(in, msg); err != nil {
		return err
	}
	p.Success = msg
	return nil
}

func (p *FavoriteVideoResult) GetSuccess() *video.FavoriteVideoResp {
	if !p.IsSetSuccess() {
		return FavoriteVideoResult_Success_DEFAULT
	}
	return p.Success
}

func (p *FavoriteVideoResult) SetSuccess(x interface{}) {
	p.Success = x.(*video.FavoriteVideoResp)
}

func (p *FavoriteVideoResult) IsSetSuccess() bool {
	return p.Success != nil
}

type kClient struct {
	c client.Client
}

func newServiceClient(c client.Client) *kClient {
	return &kClient{
		c: c,
	}
}

func (p *kClient) CreateVideo(ctx context.Context, Req *video.CreateVideoRequest) (r *video.CreateVideoResp, err error) {
	var _args CreateVideoArgs
	_args.Req = Req
	var _result CreateVideoResult
	if err = p.c.Call(ctx, "CreateVideo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetVideoFeed(ctx context.Context, Req *video.GetVideoFeedRequest) (r *video.GetVideoFeedResp, err error) {
	var _args GetVideoFeedArgs
	_args.Req = Req
	var _result GetVideoFeedResult
	if err = p.c.Call(ctx, "GetVideoFeed", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) GetPublishList(ctx context.Context, Req *video.GetPublishListRequest) (r *video.GetPublishListResp, err error) {
	var _args GetPublishListArgs
	_args.Req = Req
	var _result GetPublishListResult
	if err = p.c.Call(ctx, "GetPublishList", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) AddFavorite(ctx context.Context, Req *video.AddFavoriteRequest) (r *video.AddFavoriteResp, err error) {
	var _args AddFavoriteArgs
	_args.Req = Req
	var _result AddFavoriteResult
	if err = p.c.Call(ctx, "AddFavorite", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) RmFavorite(ctx context.Context, Req *video.RmFavoriteRequest) (r *video.RmFavoriteResp, err error) {
	var _args RmFavoriteArgs
	_args.Req = Req
	var _result RmFavoriteResult
	if err = p.c.Call(ctx, "RmFavorite", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}

func (p *kClient) FavoriteVideo(ctx context.Context, Req *video.FavoriteVideoRequest) (r *video.FavoriteVideoResp, err error) {
	var _args FavoriteVideoArgs
	_args.Req = Req
	var _result FavoriteVideoResult
	if err = p.c.Call(ctx, "FavoriteVideo", &_args, &_result); err != nil {
		return
	}
	return _result.GetSuccess(), nil
}
